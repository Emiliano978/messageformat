---
title: "MessageFormat / (constructor)"
parent: "@messageformat/core"
grand_parent: API Reference
nav_exclude: true
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->



# MessageFormat.(constructor)

Create a new MessageFormat compiler

<b>Signature:</b>

```typescript
constructor(locale: string | PluralFunction | Array<string | PluralFunction> | null, options?: MessageFormatOptions);
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  locale | string \| [PluralFunction](./core.pluralfunction.md) \| Array&lt;string \| [PluralFunction](./core.pluralfunction.md)<!-- -->&gt; \| null | The locale or locales supported by this MessageFormat instance. |
|  options | [MessageFormatOptions](./core.messageformatoptions.md) | Options for this instance |

## Remarks

If given multiple valid locales, the first will be the default. If `locale` is empty, it will fall back to `MessageFormat.defaultLocale`<!-- -->.

String `locale` values will be matched to plural categorisation functions provided by the Unicode CLDR. If defining your own instead, use named functions, optionally providing them with the properties: `cardinals: string[]`<!-- -->, `ordinals: string[]`<!-- -->, and `module: string` (to import the formatter as a runtime dependency, rather than inlining its source).

If `locale` has the special value `'*'`<!-- -->, it will match \*\*all\*\* available locales. This may be useful if you want your messages to be completely determined by your data, but may provide surprising results if your input message object includes any 2-3 character keys that are not locale identifiers.

